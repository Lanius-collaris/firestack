diff --git a/intra/x64/dns64.go b/intra/x64/dns64.go
index 23208b0..c2b7d44 100644
--- a/intra/x64/dns64.go
+++ b/intra/x64/dns64.go
@@ -19,6 +19,7 @@ import (
 	"context"
 	"errors"
 	"net"
+	"net/netip"
 	"sync"
 
 	x "github.com/celzero/firestack/intra/backend"
@@ -59,14 +60,14 @@ var (
 type dns64 struct {
 	sync.RWMutex
 	// dns-resolver -> nat64-ips
-	ip64 map[string][]*net.IPNet
+	ip64 map[string][]netip.Prefix
 	// dns-resolver -> unique nat64-ips
 	uniqIP64 map[string]map[string]struct{}
 }
 
 func newDns64() *dns64 {
 	x := &dns64{
-		ip64:     make(map[string][]*net.IPNet),
+		ip64:     make(map[string][]netip.Prefix),
 		uniqIP64: make(map[string]map[string]struct{}),
 	}
 	go x.init()
@@ -93,7 +94,7 @@ func (d *dns64) register(id string) {
 	if l, ok := d.ip64[id]; ok {
 		log.W("dns64: overwrite existing ip64(%v) for resolver(%s)", l, id)
 	}
-	d.ip64[id] = make([]*net.IPNet, 0)
+	d.ip64[id] = make([]netip.Prefix, 0)
 	d.uniqIP64[id] = make(map[string]struct{})
 }
 
@@ -194,8 +195,8 @@ func (d *dns64) eval(network string, force64 bool, og *dns.Msg, r dnsx.Transport
 		if len(ip64) <= 0 { // can never be the case, see Local464Resolver
 			continue
 		} else {
-			for _, ipnet := range ip64 {
-				if rec := xdns.MaybeToQuadA(answer, ipnet, ttl64); rec != nil {
+			for _, prefix := range ip64 {
+				if rec := xdns.MaybeToQuadA(answer, prefix2ipnet(prefix), ttl64); rec != nil {
 					rr64 = append(rr64, rec)
 				}
 			}
@@ -353,7 +354,7 @@ func (d *dns64) addNat64Prefix(id string, ipxx *net.IPNet) error {
 	// ipxx.String -> 64:ff9b:1::/mask
 	_, exists := uniq[ipxx.String()]
 	if !exists {
-		ip64 = append(ip64, ipxx)
+		ip64 = append(ip64, ipnet2prefix(ipxx))
 		uniq[ipxx.String()] = emptyStruct
 		log.I("dns64: add ipnet [%s] for server(%s)", ipxx, id)
 	} else {
diff --git a/intra/x64/nat64.go b/intra/x64/nat64.go
index 23799f1..900fbd8 100644
--- a/intra/x64/nat64.go
+++ b/intra/x64/nat64.go
@@ -8,6 +8,7 @@ package x64
 
 import (
 	"net"
+	"net/netip"
 
 	"github.com/celzero/firestack/intra/log"
 )
@@ -25,29 +26,47 @@ func (n *nat64) IsNat64(prefix64 *net.IPNet, ip6 net.IP) bool {
 }
 
 // xAddr translates ip6 to IPv4 discarding prefix64.
-func (n *nat64) xAddr(prefix64 *net.IPNet, ip6 net.IP) net.IP {
+// If prefix64 or ip6 is not valid, it returns zerovalueaddr.
+// If ip6 is unspecified, it returns unspecified IPv4.
+func (n *nat64) xAddr(prefix64 netip.Prefix, ip6 netip.Addr) netip.Addr {
 	return ip6to4(prefix64, ip6)
 }
 
 // ip6to4 converts ip6 to IPv4 discarding prefix64.
-func ip6to4(prefix64 *net.IPNet, ip6 net.IP) net.IP {
-	ip4 := make(net.IP, net.IPv4len)
-	bitmask, _ := prefix64.Mask.Size() // prefix64 expected to be never nil
-	startByte := bitmask / 8
+func ip6to4(prefix64 netip.Prefix, ip6 netip.Addr) netip.Addr {
+	if !prefix64.IsValid() || !ip6.IsValid() {
+		return zerovalueaddr
+	}
+	if ip6.IsUnspecified() {
+		return unspecified4
+	}
+	out4 := make(net.IP, net.IPv4len)
+	raw6 := addr2ip(ip6)
+
+	ones := bitmask(prefix64) // prefix64 expected to be never nil
+	startByte := ones / 8
+	totalBytes := ip6.BitLen() / 8
+	bytes4 := net.IPv4len
 
-	if startByte+net.IPv4len > len(ip6) {
+	if startByte+bytes4 > totalBytes {
 		log.W("natpt: too long; cannot convert ip64(%v) / prefix64(%v) to ip4", ip6, prefix64)
-		return nil
+		return zerovalueaddr
 	}
 
-	for i := 0; i < net.IPv4len; i++ {
+	for i := 0; i < bytes4; i++ {
 		i6 := startByte + i
 		// skip byte 8, datatracker.ietf.org/doc/html/rfc6052#section-2.2
 		if i6 == 8 {
 			startByte++
 		}
 
-		ip4[i] = ip6[startByte+i]
+		out4[i] = raw6[startByte+i]
 	}
-	return ip4
+	return ip2addr(out4)
+}
+
+func bitmask(prefix netip.Prefix) int {
+	ones := prefix.Addr().BitLen()
+	zeros := prefix.Bits()
+	return ones - zeros
 }
diff --git a/intra/x64/natpt.go b/intra/x64/natpt.go
index d79eea8..e4c3d98 100644
--- a/intra/x64/natpt.go
+++ b/intra/x64/natpt.go
@@ -42,8 +42,9 @@ type natPt struct {
 var _ dnsx.NatPt = (*natPt)(nil)
 
 var (
-	unspecified4  = netip.IPv4Unspecified()
-	zerovalueaddr = netip.Addr{}
+	unspecified4    = netip.IPv4Unspecified()
+	zerovalueaddr   = netip.Addr{}
+	zerovalueprefix = netip.Prefix{}
 )
 
 // NewNatPt returns a new NatPt.
@@ -79,7 +80,7 @@ func (pt *natPt) do64() bool {
 // IsNat64 Implements NAT64.
 func (n *natPt) IsNat64(id string, ip netip.Addr) bool {
 	prefixes := n.nat64PrefixForResolver(id)
-	return match(prefixes, addr2ip(ip)) != nil
+	return match(prefixes, ip) != zerovalueprefix
 }
 
 // X64 Implements NAT64.
@@ -97,14 +98,13 @@ func (n *natPt) X64(id string, ip6 netip.Addr) (ip4 netip.Addr) {
 		return unspecified4
 	}
 
-	rawip := addr2ip(ip6)
 	if id == dnsx.AnyResolver {
 		for tid, prefixes := range n.ip64 {
 			if len(prefixes) <= 0 {
 				continue
 			}
-			if x := match(prefixes, rawip); x != nil {
-				return ip2addr(n.xAddr(x, rawip))
+			if x := match(prefixes, ip6); x.IsValid() {
+				return n.xAddr(x, ip6)
 			} else {
 				log.V("natpt: no matching prefix64 for ip(%v) in id(%s/%d)", ip6, tid, len(prefixes))
 			}
@@ -118,12 +118,8 @@ func (n *natPt) X64(id string, ip6 netip.Addr) (ip4 netip.Addr) {
 		log.D("natpt: no prefix64 found for resolver(%s)", ip6, id)
 		return zerovalueaddr
 	}
-	if x := match(prefixes, rawip); x != nil {
-		return ip2addr(n.xAddr(x, rawip))
-	} else {
-		log.D("natpt: no matching prefix64 for ip(%v) in id(%s/%d)", ip6, id, len(prefixes))
-	}
-	return zerovalueaddr
+	x := match(prefixes, ip6)
+	return n.xAddr(x, ip6) // may return zero value
 }
 
 // Add64 implements DNS64.
@@ -165,7 +161,7 @@ func (n *natPt) UIP(network string) []byte {
 	}
 }
 
-func (n *natPt) nat64PrefixForResolver(id string) []*net.IPNet {
+func (n *natPt) nat64PrefixForResolver(id string) []netip.Prefix {
 	if ips, ok := n.ip64[id]; !ok {
 		return nil
 	} else {
@@ -174,13 +170,13 @@ func (n *natPt) nat64PrefixForResolver(id string) []*net.IPNet {
 }
 
 // match returns the first matching prefix for ip in nets.
-func match(nets []*net.IPNet, ip net.IP) *net.IPNet {
+func match(nets []netip.Prefix, ip netip.Addr) netip.Prefix {
 	for _, p := range nets {
-		if p.Contains(ip) {
+		if p.IsValid() && p.Contains(ip) {
 			return p
 		}
 	}
-	return nil
+	return zerovalueprefix
 }
 
 func ID64(t dnsx.Transport) string {
@@ -206,3 +202,21 @@ func ip2addr(ip net.IP) netip.Addr {
 	x, _ := netip.AddrFromSlice(ip)
 	return x.Unmap()
 }
+
+func prefix2ipnet(p netip.Prefix) *net.IPNet {
+	if !p.IsValid() {
+		return nil
+	}
+	ip := addr2ip(p.Addr())
+	mask := net.IPMask(addr2ip(p.Masked().Addr()))
+	return &net.IPNet{IP: ip, Mask: mask}
+}
+
+func ipnet2prefix(ipnet *net.IPNet) netip.Prefix {
+	if ipnet == nil {
+		return zerovalueprefix
+	}
+	ip := ip2addr(ipnet.IP)
+	_, zeros := ipnet.Mask.Size()
+	return netip.PrefixFrom(ip, zeros)
+}
diff --git a/intra/xdns/dnsutil.go b/intra/xdns/dnsutil.go
index 0f36f25..2975ceb 100644
--- a/intra/xdns/dnsutil.go
+++ b/intra/xdns/dnsutil.go
@@ -1020,7 +1020,7 @@ func MakeAAAARecord(name string, ip6 string, expiry int) dns.RR {
 	return rec
 }
 
-func MaybeToQuadA(answer dns.RR, prefix *net.IPNet, minttl uint32) dns.RR {
+func MaybeToQuadA(answer dns.RR, *prefix net.IPNet, minttl uint32) dns.RR {
 	header := answer.Header()
 	if prefix == nil || header.Rrtype != dns.TypeA {
 		return nil
